# 7. closures

## clsoures 를 파라미터로 사용
```swift
func travel(action: (String) -> Void) {
    print("I'm getting ready to go.")
    action("london")
    print(description)
    print("I arrived!")
}
travel { (place: String) in
    print("I'm going to \(place) in my car")
}

```
## 값 반환시 매개변수로 closures 를 사용
```swift
func travel(action: (String) -> String) {
    print("I'm getting ready to go.")
    let description = action("London")
    print(description)
    print("I arrived!")
}
travel { (place: String) -> String in
    return "I'm going to \(place) in my car"
}
```
- 앞선 것과의 차이는 함수 호출 시 `in` 절 앞에 `-> String(return type)` 이 붙는다.
## 축약 매개 변수 이름

```swift
travel { (place: String) -> String in
    return "I'm going to \(place) in my car"
}
travel { place -> String in
    return "I'm going to \(place) in my car"
}
travel { place in
    return "I'm going to \(place) in my car"
}
travel { place in
    "I'm going to \(place) in my car"
}
travel {
    "I'm going to \($0) in my car"
}
```
- 클로저는 파라미터의 타입을 알고 있다면 생략 가능
- 클로저의 리턴 타입을 알고 있다면 생략 가능
- 만약 1줄 짜리 코드라면 return 생략 가능
- 파라미터명 대신에 달러사인과 숫자로 파라미터를 표현가능


## 함수로부터 클로저를 리턴 받기
```swift
func travel() -> (String) -> Void {
    return {
        print("I'm going to \($0)")
    }
}

```
- 첫번째 화살표는 함수의 리턴 값, 두번째 화살표는 클로저의 리턴 값이다
- return {...} 이 부분이 2번째 화살표인 클로저에 해당
- String은 1번째파라미터 string을 의미

## caputring closure
```swift
func travel() -> (String) -> Void {
    var counter = 1

    return {
        print("\(counter). I'm going to \($0)")
        counter += 1
    }
}

let result = travel()
result("London")
result("London")
result("London")
```

- counter는 함수의 클로저가 호출할때마다 증가
- 당연히 내 생각엔 함수가 호출 될 때마다 counter가 초기화되어야 할 것 같지만 아니다
- 클로저에 의해 캡쳐된다. 클로저에 의해 살아있는채로 있는다..?


# 8. struct 1
- 변수와 상수, 함수를 가지는 사용자 정의 가능한 타입
- 기본 형식
- getter는 점 찍고 필드명
```swift
struct Sport {
    var name: String
}
```
- tuple과의 차이는 공통적인 fixed data 를 위해서는 struct사용. 임시적인 경우는 tuple.

## computed properties
```swift
struct Sport {
    var name: String
    var isOlympicSport: Bool

    var olympicStatus: String {
        if isOlympicSport {
            return "\(name) is an Olympic sport"
        } else {
            return "\(name) is not an Olympic sport"
        }
    }
}
```
- vue의 computed처럼 만들어지는 필드값
- 필드가 아니라 프로퍼티가 명칭인듯 하다

## observer
- 프로퍼티가 변할때 실행할 수 있는 로직
- `didSet` 이라는 키워드를 통해 {...} 내에 로직 구현

## method
- struct 내의 func을 method라고 부른다
```swift
struct City {
    var population: Int

    func collectTaxes() -> Int {
        return population * 1000
    }
}
```

## Mutating methods
- struct가 let으로 만들어지면 프로퍼티들도 상수가 된다
- 이 경우 재할당으로 값이 변할수없게된다
- 만약 struct를 상수로, 변수로 쓸지 모를 때 `mutating` 을 사용한다
```swift
struct Person {
    var name: String

    mutating func makeAnonymous() {
        name = "Anonymous"
    }
}

let p1 = Person(name: "let")

p.name = "changed?" // X

var p2 = Person(name: "var")

p.name = "changed?" // X

```
- 이 경우, 메서드를 통한 프로퍼티 변경만 허용되고 직접 할당 또한 안된다!
- 자바에서 필드를 private으로 하고 public setter method를 만들어내는 것과 동일

## Properties and methods of strings
- String 은 struct다. 그래서 구현된 유용한 프로퍼티들이 있음

```swift
let name = "최상현"
print(name.count, name.isEmpty, name.uppercased(), name.hasPrefix("최"))
// "3 false 최상현 true\n"
```

## arrays
```swift
arr.count
arr.append("최상")
arr.firstIndex(of: "최상")
let ascending: (String, String) -> Bool = {
    (left, right) in left < right
}
print(arr.sorted(by: ascending))

```

# 9. struct 2

## initializers

- struct 의 생성자
```swift

struct User {
    var username: String
    
    init() {
        username = "anonymous"
        print("user created with no param")
    }
}

let u = User()
print(u.username)


struct User {
    var username: String
    
    init(username: String) {
        self.username = username
        print("user created with no param")
    }
}
```
- self 키워드로 본인의 프로퍼티를 언급할 수 있음. 파라미터명과 동일할 때 유용

## Lazy properties

- 퍼포먼스 최적화를 위한 기능
- 필요할 때 초기화한다. 최소 1번은 호출되어야 초기화 된다.

```swift
struct Person {
    var name: String
    lazy var familyTree = FamilyTree()

    init(name: String) {
        self.name = name
    }
}

var ed = Person(name: "Ed")
ed.familyTree // 이 때 초기화!
```

## static properties
- 프로퍼티를 static으로 선언하면 모든 struct가 공유하게 됨
- 그래서 static 프로퍼티를 읽을 때는 `{StructName}.{static property}` 형식으로 읽음


## access control
- private, public property가 존재
- getter function 생성해서 읽어와야 함


# 10. classes

## class

- struct,class 의 차이점은 5개

1. `classes never come with a memberwise initializer` - 생성자 무조건 내가 만들어놔야함
```swift
class Dog {
    var name: String
    var breed: String

    init(name: String, breed: String) {
        self.name = name
        self.breed = breed
    }
}
let poppy = Dog(name: "Poppy", breed: "Poodle")

```
2. 상속이 가능함. subclassing 이라고도 함.
```swift
class Poodle: Dog {
    init(name: String) {
        super.init(name: name, breed: "Poodle")
    }
}
```
3. overriding 이 가능함
```swift
class Poodle: Dog {
    init(name: String) {
        super.init(name: name, breed: "Poodle")
    }
    
    override func bark() {
        super.bark()
        print("크르르릉!!")
    }
}

let choco = Poodle(name: "choco")
choco.bark() // 월월!! \n 크르르릉!!

```
4. final keyword : 오버라이딩, 상속 안됨. `final class Dog {..}`

3. 번쨰 차이? copy 기능.
- struct 는 복사하면 2개는 서로 다름. class 는 값 복사가 아닌 참조 복사
- 즉 서로 영향을 미침
```swift
var dog1 = Dog(name: "초코", breed: "진돗개")

var dog2 = dog1

dog1.name = "도지"
print(dog2.name) // "도지\n"
```
